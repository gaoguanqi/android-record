设计模式的六大原则：
1.单一职责原则（Single Responsibility Principle, SRP）
        定义：一个类应只包含单一的职责。

        一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的。
        其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则。


2.开放封闭原则(Open - ClosedPrinciple ,OCP)
        定义：一个模块、类、函数应当是对修改关闭，扩展开放。

        修改原有的代码可能会导致原本正常的功能出现问题。
        因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码。


3.里氏代换原则( Liskov Substitution Principle ,LSP )
        定义：使用父类的地方能够使用子类来替换，反过来，则不行。

        使用子类对象去替换父类对象，程序将不会产生错误
        因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
    需要注意的是：
        子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。如果一个方法只存在子类中，没有在父类中声明，则无法在以父类定义的对象中使用该方法。
        父类应当被尽量设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现


4.依赖倒转原则( Dependence Inversion Principle ,DIP )
        定义：抽象不应该依赖于细节，细节应当依赖于抽象。

        即要面向接口编程，而不是面向具体实现去编程。
        高层模块不应该依赖低层模块，应该去依赖抽象。


5.接口隔离法则(Interface Segregation Principle，ISL）
        定义：一个类对另一个类的依赖应该建立在最小的接口上。

        一个类不应该依赖他不需要的接口。
        接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口。


6.迪米特法则(Law of Demeter, LoD)
        定义：一个类尽量不要与其他类发生关系

        一个类对其他类知道的越少，耦合越小。
        当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。


设计模式的分类：
        设计模式一般分为三类：创建型模式、结构型模式、行为型模式。
1 创建型模式
        创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。
        单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。
        建造者模式 ： 用来创建复杂的复合对象。
        工厂方法模式 ：让子类来决定要创建哪个对象。
        抽象工厂模式 ：创建多个产品族中的产品对象。
        原型模式 ：通过复制原型来创建新对象。

2 行为型模式
        行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
        策略模式 ：封装不同的算法，算法之间能互相替换。
        状态模式 ：根据不同的状态做出不同的行为。
        责任链模式 ：将事件沿着链去处理。
        观察者模式 ：状态发生改变时通知观察者，一对多的关系。
        模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。
        迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。
        备忘录模式 ：保存对象的状态，在需要时进行恢复。
        访问者模式 ：稳定数据结构中，定义新的操作行为。
        中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。
        解释器模式 ：定义语法，并对其进行解释。
        命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。

3 结构型模式
        结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
        代理模式 ：控制客户端对对象的访问。
        组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。
        适配器模式 ：将原来不兼容的两个类融合在一起。
        装饰者模式 ：为对象添加新功能。
        享元模式 ：使用对象池来减少重复对象的创建。
        外观模式 ：对外提供一个统一的接口用来访问子系统。
        桥接模式 ：将两个能够独立变化的部分分离开来。

4. 其他设计模式
        另外，除了这23种经典的设计模式，还涌现出其他的一些新的设计模式，比如：规格模式、对象池模式、雇工模式、黑板模式和空对象模式等等。后面有时间的话也会对这些模式进行分析。

5.最后
        虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。

        但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。
